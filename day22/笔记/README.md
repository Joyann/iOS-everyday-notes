# id 类型

- 静态类型和动态类型
  
  - 静态类型：
    
    将一个指针变量定义为特定类的对象时,使用的是静态类型,在__编译__的时候就知道这个指针变量所属的类,这个变量总是存储特定类的对象。使用的大部分都是静态类型。
    
    ``` objective-c
    Person *person = [Person new];
    ```
    
  - 动态类型：
    
    直到__运行__时才确定对象所属的类。
    
    ``` objective-c
    id obj = [Person new];
    ```
  
- 动态类型
  
  - 前面提到过父类指针指向子类对象，如果父类指针想要调用子类特有的方法，需要强制类型转换否则会报错：
    
    ``` objective-c
    Person *person = [Student new];
    Student *student = (Student *)person;
    [student sayMySchool]; // sayMySchool为Student类特有方法
    ```
    
  - 我们知道NSObject是所有类的基类，那么也就是说NSObject类的指针可以指向它的任意子类，但是刚才说过，如果想要调用子类的特有方法，需要强制类型转换：
    
    ``` objective-c
    NSObject *obj = [Cat new];
    Cat *cat = (Cat *)obj;
    [cat eat]; // eat为Cat类特有方法
    ```
    
  - id是一种通用的对象类型，它可以指向属于任何类的对象，也可以理解为__万能指针__。因为id是动态类型，所以通过id类型直接调用对象的方法不需要强制转换，编译器也不会报错：
    
    ``` objective-c
    id obj = [Cat new];
    [obj eat]; // 不用强制类型转换
    ```
    
  - 可以将 id 与 NSObject * 一起理解，它们都可以代表指向任何类的对象的指针，但是是不同的：
    
    NSObject * 是__静态类型__，在__编译时__就会确定类型。
    
    id 是__动态类型__，在__运行时__才会确定类型。
    
  - 所以在Student类.h中声明一个独有的方法sayHello（子类独有的方法），用NSObject *obj来代表指向这个对象的指针，如果不进行强制类型转换，那么obj是看不到sayHello这个方法的，因为在NSObject中并没有sayHello方法，所以编译器会报错。那么需要将obj强制类型转换成（Student *）才能看到sayHello，才可以成功编译。
    
    但是如果用id obj来代表指向这个对象的指针，不进行强制类型转换是不会报错的，因为id是指向任意对象的指针，所以编译器也不确定obj指向的对象有没有eat方法，所以编译会成功通过。运行时确定obj的类型，所以可以成功执行[obj eat]。
    
  - 注意在这里有一点不要混淆，当父类指针指向子类对象，这个指针想要调用子类特有的方法时，可以用id省去强制类型转换。但是，这不代表id类型的指针可以随意调用子类的__私有方法__（注意前面我们一直说的是__特有方法__，不是__私有方法__，在这里特有方法指的是子类特有，但是也在.h文件里声明的；而私有方法是没有在.h文件声明的），因为私有方法不会在.h文件声明，那么如果用id也会报错，因为还未等到运行时，编译都通不过。
    
    ``` objective-c
    // 比如，Student是Person的子类，Student有一个learning方法，但是没有在.h声明，即私有方法
    id obj = [Student new];
    [obj learning]; // 报错，编译不通过
    ```
    
    只有你在Student.h中声明这个方法才能编译通过。
    
  - 所以再总结就是，__id可以在父类指针指向子类对象，父类指针想要调用子类方法时候省去强制类型转换，但是前提是这个子类方法是在.h中声明的，而不是私有方法。__（多态的目的是简化编程接口之类的，所以可以用父类指针来调用不同的子类的方法而不用创建多个方法来分别调用。如果一个类，既然都没有在.h文件中对外公开一个方法，那么很显然用多态是没有意义的，因为父类指针都用不了你，何来简化一说呢？所以如果子类方法没有在.h中声明，即使用的是id，那么编译也会通不过。注意这里用id的目的是简化（省去强制类型转换），而不是随意的向一个对象发送消息看看到底有没有这个方法，所以使用多态的前提是__方法是可用的（在.h中声明）__而__不是将方法隐藏起来，那么谁都调用不了，这样做没有意义，所以编译也通不过__，这是我的理解。）
    
  - 如果你碰巧在验证的时候，在子类中写了一个-(void)test__私有方法__，你会发现用id类型是可以成功调用这个方法的，与刚才我们说的不一样。
    
    ``` objective-c
    id obj = [Student new];
    [obj test]; // test方法是Student类的私有方法
    ```
    
    我是这样理解的：系统有一个自己的test方法，obj是可以看到test方法的，因为obj指向什么类型还不确定，但是它可以看到test方法（因为test方法是系统的），所以编译器就让编译通过了。但是真正运行时，确定obj是Student *类型的，那么会真正调用Student中实现的test方法，所以会成功。
    
    类似的还有-(void)load方法等。
    
    由此也可以知道，动态类型在编译时只要”骗”过编译器成功编译，那么在真正运行时它会找到真正的类型来执行操作。
    
    ​
    
    ​
  
- 注意，__id类型不能使用点语法, 因为点语法是编译器特性, 而id是运行时特性__。
  
- 不要滥用动态类型：
  
  - 如没有使用到多态尽量使用静态类型
    
  - 静态类型可以更早的发现错误(在编译阶段而不是运行阶段)
    
  - 静态类型能够提高程序的可读性
    
  - 使用动态类型前最好判断其真实类型
    
    ``` objective-c
    - (BOOL)isKindOfClass:classObj // 判断实例对象是否是这个类或者这个类的子类的实例
    - (BOOL)isMemberOfClass:classObj // 判断是否是这个类的实例
    + (BOOL)isSubclassOfClass:classObj // 判断类是否是指定类的子类
    ```
    
    ​