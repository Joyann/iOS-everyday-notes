- 二维数组初始化和一维数组相似，不过二维数组可以忽略__行数__（即第一个括号里的数字），但是不能忽略__列数__（即第二个括号里的数字）。因为我们可以通过第二个括号中的数字和数组中一共的元素个数可以推断出__行数__，所以可以忽略列数。但是反过来是不能的，所以要注意不能忽略第二个中括号里的内容。

- 二维数组的存放顺序是按行存放的，先存放第一行的元素，再存放第2行的元素。

- 二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入。（这一点和一维数组是一样的，在数组作为参数的过程中，会被认为是指针，即8个字节）

  ``` objective-c
  void test(char cs[2][3])
  {
      int row = sizeof(cs);
      printf("row = %zu\n", row);
  }
  输出结果:
  row = 8
  ```

  但是__二维数组作为函数参数，在被调函数中是可以计算出二维数组有多少列的__。

  ``` objective-c
  void test(char cs[2][3])
  {
      size_t col = sizeof(cs[0]);
      printf("col = %zd\n", col);
  }
  输出结果:
  col = 3
  ```

  所以在这里总结一下：如果二维数组作为函数的参数，在传递的过程中被认为是指针，所以如果在被调函数中用sizeof直接计算数组共有多少行总是会得到8，因为数组被当作了指针。但是在被调函数中，如果我们用sizeof计算这个数组的某个元素，那么相当于计算的是数组里的数组，所以是可以得到准确的列数的。

- __字符串__：

  - 初始化
    1. char myString[9] = “hello"; //在内存中以“\0”结束， \0 ASCII码值是0
    2. char myString1[9] = {‘h’,'e’,'l’,’l’,’o','\0'};
    3. char myString2[9] = {‘h’,'e’,'l’,’l’,’o’, 0};
    4. char myString3[9] = {‘h’,'e’,'l’,’l’,’o’}; //静态数组如果没有赋值默认就是0，0就相当于\0


  - __\0__是字符串的标志。

  - __\0__是字符串结束的标志。

  - “ “ 一定是字符串。

  - 字符串的本质是数组，不过最后一个元素的\0。（可以看到初始化里面第2，3，4例子）

  - char myString4[] = {‘h’,’e’,’l’,’l’,’o’}; 不是字符串而是普通的数组。这与初始化里的第4条相似，但是是不同的。初始化第4条的例子前面规定包含了9个元素，后面赋值了5个，相当于__部分初始化__，所以后面会自动补0，那么相当于有了\0，所以是字符串；而在本例中，并不会自动补充0，所以这就是一个普通的数组。

  - 总结就是如果想方便的得到字符串，那么直接用”"即可，比如：char myString[] = “hello”；如果想用字符数组来得到字符串，需要在最后加上\0。

  - 字符串输出：

    1. char myString[] = “hello";

       printf("%s\n", myString);

    2. 但是注意这个问题：

       ``` objective-c
       char myString[] = {'h', 'e', 'l', 'l', 'o' '\0'};
       char myArray[] = {'j', 'o', 'y'};
       printf("myArray = %s\n", myArray);
       ```

       %s的本质是根据首地址逐个输出元素直到遇到\0。前面提高过变量寻址由大到小（Excel表相当于myArray在myString上面，地址比myString要小），所以输出完myArray后没遇到\0将会继续输出紧挨着的内存中的内容，即myString中的元素，直到遇到\0。所以结果为__joyhello__。

  - 字符串输入：

    1. char ch[10];

       scanf("%s",ch);

       注意：

       - 对一个字符串数组, 如果不做初始化赋值, 必须指定数组长度
       - ch最多存放由9个字符构成的字符串，其中最后一个字符的位置要留给字符串的结尾标示‘\0’当用scanf函数输入字符串时,字符串中不能含有空格,否则将以空格作为串的结束符。

  - 字符串数组：

    1. char myArray1\[2\]\[10\] = { {‘h’,'e’,’l’,’l’,'o','\0'}, {‘w’,’o’,'r’,’l’,’d','\0'} };
    2. char myArray2\[2\]\[10\] = { {“hello"}, {“world"} };
    3. char myArray3\[2\]\[10\] = { “hello", “world" };

- __指针为什么要区分类型__：

  - 在同一种编译器环境下,一个指针变量所占用的内存空间是固定的。比如,在16位编译器环境 下,任何一个指针变量都只占用8个字节,并不会随所指向变量的类型而改变。

  - 虽然所有的指针都只占8个字节,但不同类型的变量却占不同的字节数。

    一个int占用4个字节，一个char占用1个字节，而一个double占用8字节；

    现在只有一个地址，我怎么才能知道要从这个地址开始向后访问多少个字节的存储空间呢，是4个，是1个，还是8个。

    所以指针变量需要它所指向的数据类型告诉它要访问多少个字节存储空间

  - 也就是说，如果不指定指针的类型，那么当指针指向一个变量的时候，她从首地址开始，但是它不知道什么时候停止，它不知道要访问多少个存储空间。比如有一个char类型的变量，我用一个指针指向它，但是这个指针我设置成int类型，这样一来这个指针就会向后访问四个字节的存储空间，很明显得到的结果不是char类型应该得到的，所以要区分类型。
