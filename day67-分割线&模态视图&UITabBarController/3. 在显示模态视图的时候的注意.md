无论使用push的方式显示视图还是modal的方式显示视图，其本质都会`移除原来显示的视图`，但是`原来的视图并未销毁`。

比如在AController（对应AView）上以push的方式显示BController对应的BView（当然A处于导航控制器中），此时A会被加到navigationController的`viewControllers`这个数组里面，所以navigationController有强指针指向AController保证其不被销毁，这也保证了AView不被销毁。当进行push的时候，BController也会被加入到navigationController的`viewControllers`中，保证不被销毁。__当BView显示的时候，会将AView移除，这保证了在navigationController显示的view层级中只有一个当前正在显示的view。__

虽然AView被移除（即不被显示），但是__这个对象并没有被销毁，因为AController没有被销毁。__

如果返回，那么BController会从`viewControllers`中移除，也就是说没有强指针指向它，则BController会被销毁，那么BView从屏幕上移除，接着也会被销毁。

这样想是正常的，因为保证了同时显示的view层级中只有当前显示的view，而原来的view也并未销毁。当执行返回操作的时候，返回的view会从屏幕消失并且被销毁。

但是在显示模态视图的时候可能会有一些疑惑。

如果我们在AController的Aview上模态显示BController的BView，根据之前说的，此时AView在显示的view层级中已经被移除，但是AController有强指针指向，所以AView不会被销毁，这和之前说的是一样的。此时BView显示在屏幕上，说明BView没有被销毁，也就是说明BController没有被销毁，但是这不同于上面说的例子，在此时并没有navigationController来管理子控制器，也就是说没有`viewControllers`这样一个数组来强引用BController，而BController又不会被销毁，这很奇怪。

事实上，因为我们在AController的view上模态显示BController的view，那么AController有一个名为`presentedViewController`的强指针来指向它模态显示出的控制器，即BController，这样AController存在就保证BController存在，然后就保证BView存在。

所以说，当使用模态视图的时候，被模态显示的视图对应的控制器实际上由将它显示出的控制器来管理。

通过控制器的`presentedViewController`属性可以获得这个控制器模态显示出来的控制器。

通过控制器的`presentingViewController`属性可以获得谁正在模态显示当前这个控制器。